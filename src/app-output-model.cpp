/*
 * font2c - Command-line utility for converting font glyphs into bitmap images
 * embeddable in C source code.
 *
 * https://github.com/mattbucknall/font2c
 *
 * Copyright (C) 2022 Matthew T. Bucknall
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
 * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <cassert>
#include <cerrno>
#include <cstdio>
#include <cstring>
#include <filesystem>
#include <utility>

#include <fmt/format.h>

#include "app-output-model.hpp"
#include "app-version.hpp"

using namespace app;


OutputModel::OutputModel(int depth, bool msb_first, RasterizerFunc rasterizer_func):
    m_rasterizer_func(std::move(rasterizer_func)),
    m_line_ascent(0),
    m_line_descent(0),
    m_line_height(0),
    m_current_byte(0) {
    assert(depth == 1 || depth == 2 || depth == 4 || depth == 8);

    m_shift = 8 - depth;

    if ( msb_first ) {
        m_start = depth - 1;
        m_delta = -depth;
    } else {
        m_start = 0;
        m_delta = depth;
    };

    m_bit_pos = m_start;
}


int OutputModel::line_ascent() const {
    return m_line_ascent;
}


int OutputModel::line_descent() const {
    return m_line_descent;
}


int OutputModel::line_height() const {
    return m_line_height;
}


std::optional<font2c_glyph_t> OutputModel::find_glyph(char32_t codepoint) const {
    for(const auto& glyph: m_glyphs) {
        if (  glyph.codepoint == codepoint ) {
            return glyph;
        }
    }

    return std::nullopt;
}


const std::vector<uint8_t>& OutputModel::pixel_data() const {
    return m_pixel_data;
}


void OutputModel::add_glyph(const app::Glyph& glyph) {
    font2c_glyph_t f2c_glyph = {
            .codepoint = glyph.codepoint(),
            .offset = static_cast<uint32_t>(m_pixel_data.size()),
            .x_bearing = static_cast<int16_t>(glyph.x_bearing()),
            .y_bearing = static_cast<int16_t>(glyph.y_bearing()),
            .width = static_cast<uint16_t>(glyph.width()),
            .height = static_cast<uint16_t>(glyph.height()),
            .x_advance = static_cast<int16_t>(glyph.x_advance()),
            .y_advance = static_cast<int16_t>(glyph.y_advance())
    };

    m_glyphs.push_back(f2c_glyph);
    m_rasterizer_func(*this, glyph);

    m_line_ascent = std::max(m_line_ascent, static_cast<int>(f2c_glyph.y_bearing));
    m_line_descent = std::max(m_line_descent, f2c_glyph.height - f2c_glyph.y_bearing);
    m_line_height = std::max(m_line_height, m_line_ascent + m_line_descent);
}


void OutputModel::add_pixel(uint8_t opacity) {
    opacity >>= m_shift;
    opacity <<= m_bit_pos;

    m_current_byte |= opacity;
    m_bit_pos += m_delta;

    if ( m_bit_pos < 0 || m_bit_pos >= 8 ) {
        flush_pixels();
    }
}


void OutputModel::flush_pixels() {
    if ( m_bit_pos != m_start ) {
        m_pixel_data.push_back(m_current_byte);
        m_bit_pos = m_start;
        m_current_byte = 0;
    }
}


void OutputModel::write(std::string_view path, std::string_view font_path, const app::Options& options) const {
    struct File {
        FILE* f;

        explicit File(std::string_view path) :
                f(std::fopen(path.data(), "w")) {
            if (f == nullptr) {
                throw app::Error("{}", std::strerror(errno));
            }
        }

        ~File() {
            std::fclose(f);
        }

        operator FILE*() const { // NOLINT(google-explicit-constructor)
            return f;
        }
    };

    File f(path);
    size_t total_size = m_pixel_data.size() + (m_glyphs.size() * sizeof(font2c_glyph_t));

    fmt::print(f, "/*\n");
    fmt::print(f, " * Generated by font2c, version {}\n", APP_VERSION_STR);
    fmt::print(f, " * https://github.com/mattbucknall/font2c\n");
    fmt::print(f, " *\n");
    fmt::print(f, " * Source Font:          {}\n", std::filesystem::path(font_path).filename().string());
    fmt::print(f, " * Font Size:            {}px\n", options.size);
    fmt::print(f, " * Pixel Depth:          {}bpp\n", options.pixel_depth);
    fmt::print(f, " * Raster Order:         {}\n", options.raster_type);
    fmt::print(f, " * Bit Order:            {}\n", options.msb_first ? "msb first" : "lsb first");
    fmt::print(f, " * Antialiased:          {}\n", options.antialiasing ? "yes" : "no");
    fmt::print(f, " * Hinting:              {}\n", options.no_hinting ? "no" : "yes");
    fmt::print(f, " * Glyph Count:          {}\n", m_glyphs.size());
    fmt::print(f, " * Combined Table Size:  {} bytes\n", total_size);
    fmt::print(f, " */\n\n");

    fmt::print(f, "#include <font2c-types.h>\n\n\n");

    fmt::print(f, "static const uint8_t PIXELS[{}] = {{\n    ", m_pixel_data.size());

    int count = 0;

    for (auto byte: m_pixel_data) {
        fmt::print(f, "0x{:02X}, ", byte);
        count++;

        if ( count == 16 ) {
            fmt::print(f, "\n    ");
            count = 0;
        }
    }

    if ( count > 0 ) {
        fmt::print(f, "\n");
    }

    fmt::print(f, "}};\n\n\n");

    fmt::print(f, "static const font2c_glyph_t GLYPHS[{}] = {{\n", m_glyphs.size());

    for (const auto& glyph: m_glyphs) {
        fmt::print(f, "    0x{:08X}, 0x{:08X}, {:>6}, {:>6}, {:>6}, {:>6}, {:>6}, {:>6},\n",
                   glyph.codepoint, glyph.offset, glyph.x_bearing, glyph.y_bearing,
                   glyph.width, glyph.height, glyph.x_advance, glyph.y_advance);
    }

    fmt::print(f, "}};\n\n\n");

    fmt::print(f, "const font2c_font_t {} = {{\n", options.symbol_name);
    fmt::print(f, "    .pixels =       PIXELS,\n");
    fmt::print(f, "    .glyphs =       GLYPHS,\n");
    fmt::print(f, "    .n_glyphs =     {},\n", m_glyphs.size());
    fmt::print(f, "    .ascent =       {},\n", m_line_ascent);
    fmt::print(f, "    .descent =      {},\n", m_line_descent);
    fmt::print(f, "    .line_height =  {},\n", m_line_height);
    fmt::print(f, "    .compression =  FONT2C_COMPRESSION_NONE\n");
    fmt::print(f, "}};\n\n\n");
    fmt::print(f, "/* === end of file === */\n\n");
}
